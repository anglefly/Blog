---
title: Node.js实现一个express框架
author: Peter酱
categories: 
  - 技术
  - 技术文档
  - webpack
tags: 
  - null
date: 2020-08-07 23:17:13
permalink: /pages/4cc5c0/
---

## express的基本用法
```js
const express = require("express");
const app = express();

app.get("/test", (req, res, next) => {
  console.log("会所技师到位*1");
//   res.end("会所技师开始服务1");
  next();
});

app.get("/test", (req, res, next) => {
  console.log("会所技师到位*2");
  res.end("会所技师开始服务2");
});

app.listen(8888, (err) => {
  !err && console.log("会所里面有大保健吗?");
});
```
1. 当我访问`localhost:8888/test`时候,返回了:会所技师开始服务 2,服务端打印了

```
会所技师到位*1
会所技师到位*2
```

2. 从上面可以看到什么?

- `app.listen` 会启动进程监听端口
- 每次收到请求,对应的`url`和`method`会触发相应挂载在`app`上对应的回调函数
- 调用 `next` 方法,会触发下一个
- `express`默认引入调用后返回一个`app`对象

## 一起来实现一个简单的express框架

1. 定义属于我们的`express`文件入口,这里使用`class`来实现

```js
class express {

}

module.exports = express;
```

2. 需要的原生模块`http`,创建进程监听端口

```js
const { createServer } = require("http");
```

3. 给 `class` 定义 `listen` 方法,监听端口
```js
class express {
  listen(...args) {
    createServer(cb).listen(...args);
  }
}
```

4. 这样就可以通过调用 `class` 的 `listen` 去调用 `http` 模块的 `listen` 了,这里的`cb`我们可以先不管,你要知道每次接受到请求,必然会调用 `cb` 函数,这个是 `createServer` 原生模块帮我们封装好的

## 实现接收到请求触发

1. 实现`app.get`` app.post`等方法

- 目前我们接受到响应,就会触发 `cb` 这个回调函数,那我们打印下,看看是什么参数?
```js
class express {
  cb() {
    return (req, res) => {
      console.log(res, res, "来客人了");
    };
  }
  listen(...args) {
    createServer(this.cb()).listen(...args);
  }
}
```
  - 发现此时的 `req` 和 `res` 正是我们想要的可读流和可写流.
    ![img](https://mmbiz.qpic.cn/mmbiz_png/iawKicic66ubH4P8JgY9UsMqpmXjic8oeO1uxfCGz4l6txzjcEOJTtpkKffDlRcGxt48366x8nmJ3WT7Slb0Cl3q5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
2. 开始编写 `get` 和 `post` 方法
- 这里注意,有路由是'/'的,这种是不管任何路由都会触发一次

```js
  constructor() {
    this.routers = {
      get: [],
      post: [],
    };
  }

  get(path, handle) {
    this.routers.get.push({
      path,
      handle,
    });
  }
  post(path, handle) {
    this.routers.post.push({
      path,
      handle,
    });
  }
```
- 初始化时候定义 `get`、`post` 的数组储存对应的 `path` 和 `handle`.
- 需要触发路由回调的时候,首先要找到对应的请求方式下对应的 `url` 的 `handle` 方法,然后触发回调.
- 如何找到对应请求方式下的 `url` 对应的 `handle` 方法? 在接到请求时候就要遍历一次
  - 这里要考虑匹配多个路由,意味着,我们可能遇到像最开始一样,有两个 `get` 方式的 `test` 路由
  ```js
  cb() {
    return (req, res) => {
      const method = req.method.toLowerCase();
      console.log(this.routers[method], ",method");
      const url = req.url;
      this.routers[method].forEach((item) => {
        item.path === url && item.handle(req, res);
      });
    };
  }
  listen(...args) {
    createServer(this.cb()).listen(...args);
  }
  ```

- 上面根据 `method` 找到对应的数组,遍历找到请求的路由,触发回调,此时已经能正常返回数据了
```js
[ { method: 'get', path: '/test', handle: [Function] } ] ,method
```
- 此时最简单的`express`已经完成了,但是我们好像忘了最重要的中间件

## 完成最重要的中间件功能
1. 首先要知道,express中间件分两种,一种带路由的,那就是根据路由决定是否触发
2. 另外一种就是不带路由的,像静态资源这种. 是用户访问任何路由都要触发一次的
3. 那我们需要一个 all 数组储存这种任意路由都需要匹配触发的
  ```js
 constructor() {
    this.routers = {
      get: [],
      post: [],
      all: [],
    };
  }
```

4. 之前的直接通过 push 方式是太粗暴.如果用户需要中间件功能,不传路由,那就要做特殊处理,这里通过一个中间函数处理下

  - 改造get、post方法,定义handleAddRouter方法
  ```js
  handleAddRouter(path, handle) {
    let router = {};
    if (typeof path === "string") {
      router = {
        path,
        handle,
      };
    } else {
      router = {
        path: "/",
        handle: path,
      };
    }
    return router;
  }

  get(path, handle) {
    const router = this.handleAddRouter(path, handle);
    this.routers.get.push(router);
  }

  post(path, handle) {
    const router = this.handleAddRouter(path, handle);
    this.routers.post.push(router);
  }

  use(path, handle) {
    const router = this.handleAddRouter(path, handle);
    this.routers.all.push(router);
  }
  ```

5. 每次添加之前,先触发一次`handleAddRouter`,如果是 `path` 为空的中间件,直接传入函数的,那么 `path` 帮它设置成'/'
6. 我们还遗留了一个点,`next`的实现,因为我们现在加了`all`这个数组后,意味着可能有多个中间件,那么可能一次请求打过来,就要触发多个路由
>❝
>这里要注意,`promise.then` 源码实现和 `express` 的 `next`、以及 `koa` 的洋葱圈、`redux` 的中间件实现,有着一丁点相似,当你能真的领悟前后端框架源码时候,发现大都相似
>
>❞

## 实现next
1. 思路：
  - 首先要找到所有匹配的路由
  - 然后逐个执行(看 `next` 的调用)
2. 定义`search`方法,找到所有匹配的路由
```js
search(method, url) {
  const matchedList = [];
  [...this.routers[method], ...this.routers.all].forEach((item) => {
    item.path === url && matchedList.push(item.handle);
  });
  return matchedList;
}

cb() {
  return (req, res) => {
    const method = req.method.toLowerCase();
    const url = req.url;
    const matchedList = this.search(method, url);
  };
}
```
3. `matchedList`就是我们想要找到的所有路由
4. 为了完成`next`,我们要将`req` ,`res` , `matchedList`存入闭包中,定义`handle`方法
```js
handle(req, res, matchedList) {
  const next = () => {
    const midlleware = matchedList.shift();
    if (midlleware) {
      midlleware(req, res, next);
    }
  };
  next();
}
cb() {
  return (req, res) => {
    const method = req.method.toLowerCase();
    const url = req.url;
    const matchedList = this.search(method, url);
    this.handle(req, res, matchedList);
  };
}
```

![img](https://mmbiz.qpic.cn/mmbiz_png/iawKicic66ubH4P8JgY9UsMqpmXjic8oeO1upWm4hrRb8US64YUOdkYsRjWWiaZuib1e1XOOXs8RRoSvorAO8LUNWVgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

5. 这样我们就完成了`next`方法,只要手动调用 `next` 就会调用下一个匹配到的路由回调函数

![img](https://mmbiz.qpic.cn/mmbiz_png/iawKicic66ubH4P8JgY9UsMqpmXjic8oeO1uzFWnXfS4uhVnxJ8gS1bW2rkuXPoA07ia3YVLHILbgicl78S645lqAefg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
