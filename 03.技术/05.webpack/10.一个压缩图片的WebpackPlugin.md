---
title: 一个压缩图片的WebpackPlugin
sticky: 1
author: IQ前端 JowayYoung
categories:
  - 技术
  - 技术文档
  - webpack
tags:
  -
---

# 一个压缩图片的WebpackPlugin

若经常关注性能优化的话题，可能会发现无论怎样对代码做最好的优化也不及对一张图片做一次压缩好。所以压缩图片成了性能优化里最常见的操作，不管是手动压缩图片还是自动压缩图片，在项目开发过程中必须得有。

自动压缩图片通常在`webpack`构建项目时接入一些第三方`Loader&Plugin`来处理。打开`Github`，搜素`webpack image`等关键字，`Star`最多还是`image-webpack-loader`和`imagemin-webpack-plugin`这两个`Loader&Plugin`。很多同学可能都会选择它们，方便快捷，简单易用，无脑接入。

可是，这两个`Loader&Plugin`存在一些特别问题，它们都是基于`imagemin`开发的。`imagemin`的某些依赖托管在国外服务器，在`npm i xxx`安装它们时会默认走`GitHub Releases`的托管地址，若不是规范上网，你们是不可能安装得上的，即使规范上网也不一定安装得上。所以笔者又刨根到底发表了一篇关于NPM镜像处理的文章《聊聊NPM镜像那些险象环生的坑》，专门解决这些因为网络环境而导致安装失败的问题。除了这个安装问题，`imagemin`还存在另一个大问题，就是压缩质感损失得比较严重，图片体积越大越明显，压缩出来的图片总有几张是失真的，而且总体压缩率不是很高。这样在交付项目时有可能被细心的QA小姐姐抓个正着，怎么和设计图对比起来不清晰啊！

## 工具

### 图片压缩工具

此时可能有些同学已转战到手动压缩图片了。比较好用的图片压缩工具无非就是以下几个，若有更好用的工具麻烦在评论里补充喔！同时笔者也整理出它们的区别，供各位同学参考。

![img](https://mmbiz.qpic.cn/mmbiz_png/v735W8ZTLWnQkSibwV3neZmE5paiaVlTllbQ77rl6nIHs17KuoricUTpxGYQNnXbT5pibgiaRcdHclcvVFPhs01IZeA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

| 工具 |	开源 |	收费 |	API |	免费体验 |
| ---  | ---- | ----  | ---- | -------- |
|QuickPicture	|✖️ |	✔️ |	✖️ |	可压缩类型较多，压缩质感较好，有体积限制，有数量限制|
|ShrinkMe|✖️|	✖️|	✖️|	可压缩类型较多，压缩质感一般，无数量限制，有体积限制|
|Squoosh|✔️	|✖️	|✔️	|可压缩类型较少，压缩质感一般，无数量限制，有体积限制|
|TinyJpg|✖️	|✔️	|✔️	|可压缩类型较少，压缩质感很好，有数量限制，有体积限制|
|TinyPng|✖️	|✔️	|✔️	|可压缩类型较少，压缩质感很好，有数量限制，有体积限制|
|Zhitu |✖️	|✖️	|✖️	|可压缩类型一般，压缩质感一般，有数量限制，有体积限制|

从上述表格对比可看出，免费体验都会存在**体积限制**，这个可理解，即使收费也一样，毕竟每个人都上传单张10多M的图片，哪个服务器能受得了。再来就是**数量限制**，一次只能上传20张，好像有个规律，压缩质感好就限制数量，否则就不限制数量，当然收费后就没有限制了。再来就是**可压缩类型**，图片类型一般是**jpg**、**png**、**gif**、**svg**和**webp**，**gif**压缩后一般都会失真，**svg**通常用在矢量图标上很少用在场景图片上，**webp**由于兼容性问题很少被使用，故能压缩**jpg**和**png**就足够了。当然压缩质感是最优考虑，综上所述，大部分同学都会选择`「TinyJpg」`和`「TinyPng」`，其实它俩就是兄弟，出自同一厂商。

### TinyJpg/TinyPng存在问题

1. 上传下载全靠手动
1. 只能压缩`jpg`和`png`
1. 每次只能压缩20张
1. 每张体积最大不能超过5M
1. 可视化处理信息不是特别齐全

### TinyJpg/TinyPng压缩原理

**「TinyJpg/TinyPng」**使用智能有损压缩技术将图片体积降低，选择性地减少图片中相似颜色，只需很少字节就能保存数据。对视觉影响几乎不可见，但是在文件体积上就有很大的差别。而使用到智能有损压缩技术被称为「量化」。

**「TinyJpg/TinyPng」**在压缩png文件时效果更显著。扫描图片中相似颜色并将其合并，通过减少颜色数量将24位png文件转换成体积更小的8位png文件，丢弃所有不必要的元数据。

大部分png文件都有50%~70%的压缩率，即使视力再好也很难区分出来。使用优化过的图片可减少带宽流量和加载时间，整个网站使用到的图片经`「TinyJpg/TinyPng」`压缩一遍，其成效是再多的代码优化也无法追赶得上的。

<img src='https://mmbiz.qpic.cn/mmbiz_png/v735W8ZTLWnQkSibwV3neZmE5paiaVlTllI2beSTeFcKicvIPGkfhpsx2mVib4Z0ja3C7jbZ9FH6r8eXPiaphwG2pKg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1' width='200px'>

### TinyJpg/TinyPng开发API

查阅相关资料，发现`「TinyJpg/TinyPng」`暂时还未开源其压缩算法，不过提供了适合开发者使用的API。有兴趣的同学可到其开发API文档瞧瞧。

在Node方面，`「TinyJpg/TinyPng」`官方提供了`tinify`作为压缩图片的核心JS库，使用很简单，看文档吧。可是换成开发API还是逃不过收费，你是想包月呢还是免费呢，想免费的话就继续往下看，土豪随意！

![img](https://mmbiz.qpic.cn/mmbiz_png/v735W8ZTLWnQkSibwV3neZmE5paiaVlTlliavxJAtdicxl1WMichC23kd2icOkPNHIKlVoOibSYib4Dtd3Fj7r2vRr7W5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 实现

笔者也是经常使用`「TinyJpg/TinyPng」`的程序猿，收费，那是不可能的😂。寻找突破口，解决问题，是作为一位程序猿最基本的素养。我们需明确什么问题，需解决什么问题。

### 分析

从上述得知，只需对「TinyJpg/TinyPng」原有功能改造成以下功能。

- 上传下载全自动
- 可压缩jpg和png
- 没有数量限制
- 存在体积限制，最大体积不能超过5M
- 压缩成功与否输出详细信息

> 自动处理

对于前端开发者来说，这种无脑的上传下载操作必须得自动化，省事省心省力。但是这个操作得结合webpack来处理，到底是开发成Loader还是Plugin，后面再分析。不过细心的同学看标题就知道用什么方式处理了。

>压缩类型

gif压缩后一般都会失真，svg通常用在矢量图标上很少用在场景图片上，webp由于兼容性问题很少被使用，故能压缩jpg和png就足够了。在过滤图片时，使用path模块判断文件类型是否为jpg和png，是则继续处理，否则不处理。

>数量限制

数量限制当然是不能存在的，万一项目里超过20张图片，那不是得分批处理，这个不能有。对于这种无需登录状态就能处理一些用户文件的网站，通常都会通过IP来限制用户的操作次数。有些同学可能会说，刷新页面不就行了吗，每次压缩20张图片，再刷新再压缩，万一有500张图片呢，你就刷新25次吗，这样很好玩是吧！

由于大多数Web架构很少会将应用服务器直接对外提供服务，一般都会设置一层Nginx作为代理和负载均衡，有的甚至可能有多层代理。鉴于大多数Web架构都是使用Nginx作为反向代理，用户请求不是直接请求应用服务器的，而是通过Nginx设置的统一接入层将用户请求转发到服务器的，所以可通过设置HTTP请求头字段X-Forwarded-For来伪造IP。

「X-Forwarded-For」指用来识别通过代理或负载均衡的方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。当然，这个IP也不是一成不变的，每次请求都需随机更换IP，骗过应用服务器。若应用服务器增加了伪造IP识别，那可能就无法继续使用随机IP了。

>体积限制

体积限制这个能理解，也没必要搞一张那么大的图片，多浪费带宽流量和加载时间啊。在上传图片时，使用fs模块判断文件体积是否超过5M，是则不上传，否则继续上传。当然，交给「TinyJpg/TinyPng」接口判断也行。

>输出信息

压缩成功与否得让别人知道，输出原始大小、压缩大小、压缩率和错误提示等，让别人清楚这些处理信息。

### 编码

>随机生成HTTP请求头

既然可通过`X-Forwarded-For`来伪造IP，那么得有一个随机生成HTTP请求头字段的函数，每次请求接口时都随机生成相关的请求头字段。打开`tinyjpg.com`或`tinypng.com`上传一张图片，通过`Chrome DevTools`分析`Network`发现其请求接口是`web/shrink`。另外每次请求也不要集中在单一的`hostname`上，随机派发到`tinyjpg.com`或`tinypng.com`上会更好。通过封装`RandomHeader`函数随机生成请求头信息，后续使用`https`模块以`RandomHeader()`生成的配置作为入参进行请求。

`trample`是笔者开发的一个`Web/Node`通用函数工具库，包含常规的工具函数，助你少写更多通用代码。详情请查看文档，顺便给一个Star以作鼓励。

>剩下未整理，点击[此处](https://mp.weixin.qq.com/s/GmanEUfRUfuNzhPCILf3Ew)